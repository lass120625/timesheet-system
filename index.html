// å…¨åŸŸè®Šæ•¸
        let employees = {};
        let timesheetData = [];
        let pendingData = null;
        let paymentHistory = {}; // æ–°å¢ï¼šæ”¯ä»˜æ­·å²è¨˜éŒ„
        
        // å¸¸æ•¸å®šç¾©
        const REGULAR_HOURS_THRESHOLD = 304; // 8é€±é€±æœŸå…§æ­£å¸¸å·¥æ™‚ä¸Šé™
        const WEEKS_PER_CYCLE = 8; // æ¯å€‹é€±æœŸçš„é€±æ•¸
        const WEEKLY_HOURS_THRESHOLD = 38; // æ¯é€±å·¥æ™‚æ¨™æº–
        const SYSTEM_START_DATE = new Date(2025, 1, 10); // 2025å¹´2æœˆ10æ—¥ï¼ˆçµ±ä¸€é€±æœŸèµ·å§‹æ—¥ï¼‰

        // åˆå§‹åŒ–å‡½æ•¸
        document.addEventListener('DOMContentLoaded', function() {
            loadLocalData();
            updateProgress(0, 'ç³»çµ±å·²å°±ç·’ï¼Œè«‹ä¸Šå‚³å·¥æ™‚è¡¨');
            updateDataStatus();
        });

        // è¼‰å…¥æœ¬åœ°è³‡æ–™
        function loadLocalData() {
            try {
                const storedEmployees = localStorage.getItem('timesheet_employees');
                const storedTimesheetData = localStorage.getItem('timesheet_data');
                const storedPaymentHistory = localStorage.getItem('payment_history');
                
                if (storedEmployees) {
                    employees = JSON.parse(storedEmployees);
                }
                
                if (storedTimesheetData) {
                    timesheetData = JSON.parse(storedTimesheetData);
                }

                if (storedPaymentHistory) {
                    paymentHistory = JSON.parse(storedPaymentHistory);
                }
                
                updateAllTables();
                console.log('âœ… æœ¬åœ°è³‡æ–™è¼‰å…¥æˆåŠŸ');
            } catch (error) {
                console.error('è¼‰å…¥æœ¬åœ°è³‡æ–™å¤±æ•—:', error);
                showMessage('è¼‰å…¥æœ¬åœ°è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤', 'warning');
            }
        }

        // å„²å­˜æœ¬åœ°è³‡æ–™
        function saveLocalData() {
            try {
                localStorage.setItem('timesheet_employees', JSON.stringify(employees));
                localStorage.setItem('timesheet_data', JSON.stringify(timesheetData));
                localStorage.setItem('payment_history', JSON.stringify(paymentHistory));
                updateDataStatus();
                console.log('âœ… è³‡æ–™å·²å„²å­˜åˆ°æœ¬åœ°');
            } catch (error) {
                console.error('å„²å­˜æœ¬åœ°è³‡æ–™å¤±æ•—:', error);
                showMessage('å„²å­˜è³‡æ–™æ™‚ç™¼ç”ŸéŒ¯èª¤', 'error');
            }
        }

        // æ›´æ–°è³‡æ–™ç‹€æ…‹é¡¯ç¤º
        function updateDataStatus() {
            const statusDiv = document.getElementById('data-status');
            const statusText = document.getElementById('data-status-text');
            
            const empCount = Object.keys(employees).length;
            const recordCount = timesheetData.length;
            const lastUpdate = localStorage.getItem('last_update') || 'æœªçŸ¥';
            
            if (empCount > 0 || recordCount > 0) {
                statusDiv.style.display = 'block';
                statusText.textContent = `${empCount} ä½å“¡å·¥ï¼Œ${recordCount} ç­†å·¥æ™‚è¨˜éŒ„ï¼Œæœ€å¾Œæ›´æ–°ï¼š${lastUpdate}`;
            } else {
                statusDiv.style.display = 'none';
            }
        }

        // åŒ¯å‡ºå®Œæ•´è³‡æ–™
        function exportAllData() {
            if (Object.keys(employees).length === 0 && timesheetData.length === 0) {
                showMessage('æ²’æœ‰è³‡æ–™å¯ä»¥åŒ¯å‡º', 'warning');
                return;
            }

            const data = {
                employees: employees,
                timesheetData: timesheetData,
                paymentHistory: paymentHistory,
                exportDate: new Date().toISOString(),
                version: '2.1',
                systemName: 'æœ¬åœ°ç‰ˆå·¥æ™‚ç®¡ç†ç³»çµ±'
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `å·¥æ™‚ç³»çµ±å®Œæ•´è³‡æ–™_${new Date().toLocaleDateString('en-AU').replace(/\//g, '-')}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            showMessage('âœ… å®Œæ•´è³‡æ–™å·²åŒ¯å‡ºï¼');
        }

        // åŒ¯å…¥è³‡æ–™æª”
        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (data.employees && data.timesheetData) {
                        if (confirm('ç¢ºå®šè¦åŒ¯å…¥è³‡æ–™å—ï¼Ÿé€™æœƒè¦†è“‹ç¾æœ‰çš„æ‰€æœ‰è³‡æ–™ï¼')) {
                            employees = data.employees;
                            timesheetData = data.timesheetData;
                            if (data.paymentHistory) {
                                paymentHistory = data.paymentHistory;
                            } else {
                                paymentHistory = {};
                            }
                            saveLocalData();
                            updateAllTables();
                            showMessage('âœ… è³‡æ–™åŒ¯å…¥æˆåŠŸï¼');
                        }
                    } else {
                        showMessage('æª”æ¡ˆæ ¼å¼ä¸æ­£ç¢ºï¼Œè«‹é¸æ“‡æ­£ç¢ºçš„è³‡æ–™æª”', 'error');
                    }
                } catch (error) {
                    showMessage('è®€å–æª”æ¡ˆå¤±æ•—ï¼š' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            event.target.value = '';
        }

        // æ¸…é™¤æ‰€æœ‰è³‡æ–™
        function clearAllData() {
            if (confirm('âš ï¸ ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰è³‡æ–™å—ï¼Ÿé€™å°‡æœƒåˆªé™¤æ‰€æœ‰å“¡å·¥è³‡æ–™å’Œå·¥æ™‚è¨˜éŒ„ï¼Œä¸¦ä¸”ç„¡æ³•å¾©åŸï¼')) {
                employees = {};
                timesheetData = [];
                paymentHistory = {};
                localStorage.removeItem('timesheet_employees');
                localStorage.removeItem('timesheet_data');
                localStorage.removeItem('payment_history');
                localStorage.removeItem('last_update');
                updateAllTables();
                updateDataStatus();
                showMessage('ğŸ—‘ï¸ æ‰€æœ‰è³‡æ–™å·²æ¸…é™¤ï¼', 'warning');
            }
        }

        // åˆ‡æ›åˆ†é 
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        // é¡¯ç¤ºè¨Šæ¯
        function showMessage(message, type = 'success', duration = 8000) {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = type === 'error' ? 'error-message' : 
                                 type === 'warning' ? 'warning-message' : 'success-message';
            messageDiv.innerHTML = message;
            messagesDiv.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.classList.add('message-fadeout');
                messageDiv.addEventListener('transitionend', () => messageDiv.remove());
            }, duration);
        }

        // æ›´æ–°é€²åº¦æ¢
        function updateProgress(percentage, text) {
            document.getElementById('progress-fill').style.width = percentage + '%';
            document.getElementById('progress-text').textContent = text;
        }

        // é©—è­‰å“¡å·¥ç·¨è™Ÿæ ¼å¼
        function validatePayrollID(payrollId) {
            if (!payrollId) return false;
            const pattern = /^[A-Za-z]{2,3}-\d{3,4}$/;
            return pattern.test(payrollId.trim());
        }

        // è§£ææ—¥æœŸå­—ä¸²
        function parseDate(dateString) {
            if (!dateString) return null;
            
            let date = new Date(dateString);
            if (!isNaN(date.getTime()) && dateString.includes('-')) {
                return new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            }

            const partsSlash = dateString.split('/');
            if (partsSlash.length === 3) {
                date = new Date(parseInt(partsSlash[2]), parseInt(partsSlash[1]) - 1, parseInt(partsSlash[0]));
                if (!isNaN(date.getTime())) return date;
            }
            
            return null;
        }

        // å–å¾—é€±ä¸€æ—¥æœŸ
        function getMonday(date) {
            const result = new Date(date);
            const dayOfWeek = result.getDay();
            const daysToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
            result.setDate(result.getDate() + daysToMonday);
            result.setHours(0, 0, 0, 0);
            return result;
        }

        // è§£ææ™‚è–ª
        function parseRate(rateString) {
            if (!rateString) return 0;
            const cleanedString = rateString.toString().replace(/[^0-9.]/g, '');
            return parseFloat(cleanedString) || 0;
        }

        // è™•ç†æ‹–æ‹½äº‹ä»¶
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('timesheet-upload').classList.add('dragover');
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('timesheet-upload').classList.remove('dragover');
        }

        function handleDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            document.getElementById('timesheet-upload').classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    showMessage('âŒ è«‹é¸æ“‡ CSV æª”æ¡ˆ', 'error');
                    return;
                }
                
                const fileInput = document.getElementById('timesheet-file');
                const dt = new DataTransfer();
                dt.items.add(file);
                fileInput.files = dt.files;
                
                const changeEvent = new Event('change', { bubbles: true });
                fileInput.dispatchEvent(changeEvent);
                
                showMessage(`ğŸ“ å·²æ¥æ”¶æª”æ¡ˆ: ${file.name}`, 'success', 3000);
            }
        }

        // æ–°å¢ï¼šè®€å–æª”æ¡ˆå…§å®¹çš„å‡½æ•¸
        function readFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = () => reject(reader.error);
                reader.readAsText(file, 'UTF-8');
            });
        }

        // æ–°å¢ï¼šè§£æ CSV è³‡æ–™çš„å‡½æ•¸
        function parseCSV(csvData) {
            const lines = csvData.replace(/\r\n/g, '\n').split('\n');
            if (lines.length < 2) return [];
            
            const headers = lines[0].split(',').map(h => h.trim());
            const result = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = lines[i].split(',');
                const obj = {};
                for (let j = 0; j < headers.length; j++) {
                    obj[headers[j]] = values[j] ? values[j].trim() : '';
                }
                result.push(obj);
            }
            return result;
        }

        // æ–°å¢ï¼šè¨­å®šæŒ‰éˆ•è¼‰å…¥ç‹€æ…‹çš„å‡½æ•¸
        function setButtonLoading(btnId, isLoading, text) {
            const button = document.getElementById(btnId);
            const originalText = button.getAttribute('data-original-text') || button.innerText;
            if (!button.hasAttribute('data-original-text')) {
                button.setAttribute('data-original-text', originalText);
            }

            const spinner = button.querySelector('.spinner');

            if (isLoading) {
                button.disabled = true;
                if (spinner) spinner.style.display = 'inline-block';
                button.childNodes[button.childNodes.length - 1].textContent = ` ${text}`;
            } else {
                button.disabled = false;
                if (spinner) spinner.style.display = 'none';
                button.childNodes[button.childNodes.length - 1].textContent = ` ${button.getAttribute('data-original-text')}`;
            }
        }

        // è™•ç†å·¥æ™‚è¡¨ä¸Šå‚³
        async function handleTimesheetFile(event) {
            const file = event.target.files[0];
            if (!file) {
                document.getElementById('timesheet-file-info').style.display = 'none';
                updateProgress(0, 'ç­‰å¾…ä¸Šå‚³æ–‡ä»¶...');
                return;
            }
            
            document.getElementById('validation-results').innerHTML = '';
            document.getElementById('timesheet-file-info').style.display = 'none';

            setButtonLoading('upload-file-btn', true, 'è®€å–ä¸­...');

            try {
                updateProgress(20, 'æ­£åœ¨è®€å–å·¥æ™‚è¡¨...');
                
                const data = await readFile(file);
                const parsed = parseCSV(data);
                
                updateProgress(40, 'é©—è­‰è³‡æ–™æ ¼å¼...');
                
                const validationResult = validateTimesheetData(parsed);
                
                if (validationResult.errors.length > 0) {
                    showValidationResults(validationResult);
                    updateProgress(0, 'è³‡æ–™é©—è­‰å¤±æ•—');
                    showMessage('âŒ å·¥æ™‚è¡¨é©—è­‰å¤±æ•—ï¼Œè«‹æª¢æŸ¥æ ¼å¼ä¸¦é‡è©¦ã€‚', 'error');
                    return;
                }
                
                showValidationResults(validationResult);
                updateProgress(60, 'æª¢æŸ¥è³‡æ–™è¡çª...');
                
                const conflicts = checkForConflicts(parsed);
                
                if (conflicts.length > 0) {
                    showConflictDialog(parsed, conflicts);
                } else {
                    await processTimesheetData(parsed);
                }
                
            } catch (error) {
                showMessage('è®€å–å·¥æ™‚è¡¨æ™‚ç™¼ç”ŸéŒ¯èª¤: ' + error.message, 'error');
                updateProgress(0, 'è¼‰å…¥å¤±æ•—');
                console.error('File handling error:', error);
            } finally {
                setButtonLoading('upload-file-btn', false, 'é¸æ“‡å·¥æ™‚è¡¨æ–‡ä»¶');
                document.getElementById('timesheet-file').value = '';
            }
        }
        
        // æ–°å¢ï¼šé¡¯ç¤ºé©—è­‰çµæœ
        function showValidationResults(result) {
            const container = document.getElementById('validation-results');
            container.innerHTML = '<h3>ğŸ“ é©—è­‰å ±å‘Š</h3>';

            result.success.forEach(msg => {
                container.innerHTML += `<div class="validation-item validation-success">${msg}</div>`;
            });
            result.warnings.forEach(msg => {
                container.innerHTML += `<div class="validation-item validation-warning">${msg}</div>`;
            });
            result.errors.forEach(msg => {
                container.innerHTML += `<div class="validation-item validation-error">${msg}</div>`;
            });
        }
        
        // æ–°å¢ï¼šé¡¯ç¤ºä¸Šå‚³æ‘˜è¦
        function showUploadSummary(summary) {
            const container = document.getElementById('validation-results');
            let summaryHTML = `
                <div class="upload-summary">
                    <h3>âœ… ä¸Šå‚³æˆåŠŸæ‘˜è¦</h3>
                    <div class="summary-item"><span>ç¸½è™•ç†è¨˜éŒ„</span> <strong>${summary.totalRecords}</strong></div>
                    <div class="summary-item"><span>æ¶‰åŠå“¡å·¥æ•¸</span> <strong>${summary.employees.size}</strong></div>
                    <div class="summary-item"><span>æ–°å¢è¨˜éŒ„</span> <strong class="highlight">${summary.newRecords}</strong></div>
                    <div class="summary-item"><span>æ›´æ–°è¨˜éŒ„</span> <strong class="highlight">${summary.updatedRecords}</strong></div>
                </div>
            `;
            container.innerHTML += summaryHTML;
        }

        // é©—è­‰å·¥æ™‚è¡¨è³‡æ–™
        function validateTimesheetData(data) {
            const result = { success: [], warnings: [], errors: [] };
            if (data.length === 0) {
                result.errors.push('æ–‡ä»¶ç‚ºç©ºæˆ–æ ¼å¼ä¸æ­£ç¢ºï¼Œè«‹ç¢ºä¿ CSV åŒ…å«æ•¸æ“šè¡Œã€‚');
                return result;
            }
            
            const requiredFields = ['Payroll ID', 'First Name', 'Last Name', 'Monday of the Work Week', 'Hours'];
            const headers = Object.keys(data[0] || {});
            
            for (const field of requiredFields) {
                if (!headers.includes(field)) {
                    result.errors.push(`ç¼ºå°‘å¿…è¦æ¬„ä½: ${field}ã€‚è«‹æª¢æŸ¥ CSV æ¨™é¡Œè¡Œã€‚`);
                }
            }
            if (result.errors.length > 0) return result;
            
            let validRecords = 0;
            data.forEach((row, index) => {
                const payrollId = row['Payroll ID']?.trim();
                const workWeek = row['Monday of the Work Week']?.trim();
                const hours = parseFloat(row['Hours']);
                
                if (!payrollId && !workWeek) return;
                validRecords++;
                
                if (!validatePayrollID(payrollId)) {
                    result.errors.push(`ç¬¬${index + 2}è¡Œ: Payroll ID æ ¼å¼éŒ¯èª¤ (${payrollId || 'ç©º'})ã€‚`);
                }
                if (!workWeek || !parseDate(workWeek)) {
                    result.errors.push(`ç¬¬${index + 2}è¡Œ: Monday of the Work Week æ—¥æœŸæ ¼å¼éŒ¯èª¤ (${workWeek})ã€‚`);
                }
                if (isNaN(hours) || hours < 0) {
                    result.errors.push(`ç¬¬${index + 2}è¡Œ: å·¥æ™‚è³‡æ–™ç„¡æ•ˆ (${row['Hours'] || 'ç©º'})ã€‚`);
                }
            });
            
            if (result.errors.length === 0) {
                result.success.push(`âœ… æˆåŠŸé©—è­‰ ${validRecords} ç­†æœ‰æ•ˆå·¥æ™‚è¨˜éŒ„`);
            }
            return result;
        }

        // æª¢æŸ¥è³‡æ–™è¡çª
        function checkForConflicts(newData) {
            const conflicts = [];
            const existingDataMap = new Map(timesheetData.map(item => [`${item.payrollId}-${item.workWeekDate}`, item.hours]));
            
            newData.forEach(row => {
                const payrollId = row['Payroll ID']?.trim();
                const workWeekStr = row['Monday of the Work Week']?.trim();
                const parsedDate = parseDate(workWeekStr);
                if (!payrollId || !parsedDate) return;
                
                const workWeekDate = toLocalDateString(parsedDate);
                const key = `${payrollId}-${workWeekDate}`;
                const existingHours = existingDataMap.get(key);
                const newHours = parseFloat(row['Hours']) || 0;

                if (existingHours !== undefined && existingHours !== newHours) {
                    conflicts.push({ payrollId, workWeekDate, existingHours, newHours, employeeName: `${row['First Name']} ${row['Last Name']}`.trim() });
                }
            });
            return conflicts;
        }

        // é¡¯ç¤ºè¡çªè§£æ±ºå°è©±æ¡†
        function showConflictDialog(newData, conflicts) {
            const dialog = document.createElement('div');
            dialog.className = 'confirm-dialog active';
            const sampleConflicts = conflicts.slice(0, 5);
            
            let conflictsList = sampleConflicts.map(c => `
                <div class="validation-warning" style="margin-bottom: 5px;">
                    <strong>${c.employeeName}</strong> (${c.payrollId}) - ${c.workWeekDate}
                    <br>ç¾æœ‰å·¥æ™‚: <span class="highlight">${c.existingHours}</span> â†’ æ–°å·¥æ™‚: <span class="highlight">${c.newHours}</span>
                </div>
            `).join('');
            
            if (conflicts.length > 5) {
                conflictsList += `<div style="text-align:center; margin-top:10px;">...é‚„æœ‰ ${conflicts.length - 5} å€‹è¡çªæœªé¡¯ç¤º</div>`;
            }
            
            dialog.innerHTML = `
                <div class="confirm-content">
                    <h3>âš ï¸ ç™¼ç¾ ${conflicts.length} å€‹è³‡æ–™è¡çª</h3>
                    <p>ä»¥ä¸‹å·¥æ™‚è³‡æ–™å·²å­˜åœ¨ä¸”æ•¸å€¼ä¸åŒï¼Œæ˜¯å¦ç”¨æ–°è³‡æ–™è¦†è“‹ï¼Ÿ</p>
                    ${conflictsList}
                    <div class="confirm-buttons">
                        <button class="btn-confirm" onclick="confirmOverwrite(true)">è¦†è“‹ä¸¦æ›´æ–°</button>
                        <button class="btn-cancel" onclick="confirmOverwrite(false)">å–æ¶ˆä¸Šå‚³</button>
                    </div>
                </div>`;
            document.body.appendChild(dialog);
            pendingData = newData;
        }

        // ç¢ºèªè¦†è“‹è¡çª
        async function confirmOverwrite(confirmed) {
            closeDialog();
            if (confirmed && pendingData) {
                await processTimesheetData(pendingData, true);
            } else {
                updateProgress(0, 'ä¸Šå‚³å·²å–æ¶ˆ');
                showMessage('â„¹ï¸ è³‡æ–™ä¸Šå‚³å·²å–æ¶ˆã€‚');
            }
            pendingData = null;
        }

        // é—œé–‰å°è©±æ¡†
        function closeDialog() {
            const dialog = document.querySelector('.confirm-dialog');
            if (dialog) {
                dialog.classList.remove('active');
                setTimeout(() => dialog.remove(), 300);
            }
        }

        // æ ¼å¼åŒ–æ—¥æœŸç‚º YYYY-MM-DD
        function toLocalDateString(date) {
            if (!date || isNaN(date.getTime())) return '';
            return new Date(date.getTime() - (date.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
        }

        // è™•ç†å·¥æ™‚è¡¨è³‡æ–™
        async function processTimesheetData(data, overwrite = false) {
            updateProgress(10, 'é–‹å§‹è™•ç†è³‡æ–™...');
            const summary = { totalRecords: 0, employees: new Set(), newRecords: 0, updatedRecords: 0 };
            
            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                const payrollId = row['Payroll ID']?.trim();
                if (!validatePayrollID(payrollId)) continue;
                
                const workWeekStr = row['Monday of the Work Week']?.trim();
                const parsedWorkWeek = parseDate(workWeekStr);
                if (!parsedWorkWeek) continue;

                summary.totalRecords++;
                summary.employees.add(payrollId);

                const workWeekDate = toLocalDateString(parsedWorkWeek);
                const hours = parseFloat(row['Hours']) || 0;

                // æ›´æ–°å“¡å·¥è³‡æ–™
                if (!employees[payrollId]) {
                    employees[payrollId] = { payrollId, workWeeks: {}, totalHours: 0 };
                }
                Object.assign(employees[payrollId], {
                    firstName: row['First Name']?.trim(),
                    lastName: row['Last Name']?.trim(),
                    level: row['Level']?.trim() || employees[payrollId].level,
                    farm: row['Farm']?.trim() || employees[payrollId].farm,
                    hourlyRate: parseRate(row['Rate']) || employees[payrollId].hourlyRate || 0,
                });
                
                // æ›´æ–°å·¥æ™‚è¨˜éŒ„
                const recordIndex = timesheetData.findIndex(item => item.payrollId === payrollId && item.workWeekDate === workWeekDate);
                if (recordIndex !== -1) {
                    if (overwrite || timesheetData[recordIndex].hours !== hours) {
                        timesheetData[recordIndex].hours = hours;
                        summary.updatedRecords++;
                    }
                } else {
                    timesheetData.push({ payrollId, workWeekDate, hours, uploadDate: new Date().toISOString() });
                    summary.newRecords++;
                }
                
                if (i % 20 === 0) {
                   updateProgress(10 + (i / data.length) * 70, `è™•ç†ä¸­... ${i + 1}/${data.length}`);
                   await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            updateProgress(85, 'è¨ˆç®—å·¥æ™‚èˆ‡è–ªè³‡...');
            Object.values(employees).forEach(calculatePayroll);
            
            updateProgress(95, 'å„²å­˜è³‡æ–™...');
            localStorage.setItem('last_update', new Date().toLocaleString('zh-TW'));
            saveLocalData();
            
            updateProgress(100, 'å®Œæˆï¼');
            showUploadSummary(summary);
            updateAllTables();
            
            showMessage(`âœ… ä¸Šå‚³æˆåŠŸï¼æ–°å¢ ${summary.newRecords} ç­†ï¼Œæ›´æ–° ${summary.updatedRecords} ç­†`);
        }
        
        // é‡æ–°è¨ˆç®—æ‰€æœ‰å“¡å·¥è–ªè³‡ (è¼”åŠ©å‡½æ•¸)
        function recalculateAllPayrolls() {
            Object.values(employees).forEach(employee => {
                 // é‡æ–°èšåˆå·¥æ™‚
                employee.workWeeks = timesheetData
                    .filter(item => item.payrollId === employee.payrollId)
                    .reduce((acc, item) => {
                        acc[item.workWeekDate] = item.hours;
                        return acc;
                    }, {});
                employee.totalHours = Object.values(employee.workWeeks).reduce((sum, hours) => sum + (parseFloat(hours) || 0), 0);
                
                // é‡æ–°è¨ˆç®—è–ªè³‡
                calculatePayroll(employee);
            });
        }
        
        // è¨ˆç®—å“¡å·¥é€±æœŸè³‡è¨Š
        function calculateEmployeeCycle(employee) {
            const systemStartMonday = getMonday(SYSTEM_START_DATE);
            const today = new Date();
            
            const totalWeeksFromSystemStart = Math.floor((today - systemStartMonday) / (7 * 24 * 60 * 60 * 1000));
            const currentCycle = Math.max(1, Math.floor(totalWeeksFromSystemStart / WEEKS_PER_CYCLE) + 1);
            
            const cycleStartWeekIndex = (currentCycle - 1) * WEEKS_PER_CYCLE;
            const cycleStartDate = new Date(systemStartMonday);
            cycleStartDate.setDate(cycleStartDate.getDate() + cycleStartWeekIndex * 7);
            
            const cycleEndDate = new Date(cycleStartDate);
            cycleEndDate.setDate(cycleEndDate.getDate() + WEEKS_PER_CYCLE * 7 - 1);
            
            let cycleHours = 0;
            for (const workWeekDateStr in employee.workWeeks) {
                const workWeekDate = parseDate(workWeekDateStr);
                if (workWeekDate >= cycleStartDate && workWeekDate <= cycleEndDate) {
                    cycleHours += (parseFloat(employee.workWeeks[workWeekDateStr]) || 0);
                }
            }
            
            return { currentCycle, cycleStartDate, cycleEndDate, cycleHours };
        }

        // è¨ˆç®—è–ªè³‡
        function calculatePayroll(employee) {
            // å…ˆèšåˆæœ€æ–°çš„å·¥æ™‚
            employee.workWeeks = timesheetData
                .filter(item => item.payrollId === employee.payrollId)
                .reduce((acc, item) => {
                    acc[item.workWeekDate] = item.hours;
                    return acc;
                }, {});
            employee.totalHours = Object.values(employee.workWeeks).reduce((sum, hours) => sum + (parseFloat(hours) || 0), 0);


            const hourlyRate = Number(employee.hourlyRate) || 0;
            const cycleInfo = calculateEmployeeCycle(employee);
            
            let payrollData = {
                cycleHours: cycleInfo.cycleHours,
                regularHours: 0, overtimeHours: 0,
                regularPay: 0, overtimePay: 0
            };

            if (cycleInfo.cycleHours > REGULAR_HOURS_THRESHOLD) {
                payrollData.regularHours = REGULAR_HOURS_THRESHOLD;
                payrollData.overtimeHours = cycleInfo.cycleHours - REGULAR_HOURS_THRESHOLD;
            } else {
                payrollData.regularHours = cycleInfo.cycleHours;
                payrollData.overtimeHours = 0;
            }
            payrollData.regularPay = payrollData.regularHours * hourlyRate;
            payrollData.overtimePay = payrollData.overtimeHours * hourlyRate;
            
            employee.payrollData = payrollData;
            
            // è¨ˆç®—æ‰€æœ‰æ­·å²é€±æœŸçš„ç´¯ç©åŠ ç­è²»
            employee.accumulatedOvertimePay = 0;
            const allCycles = getAllAvailableCycles();
            allCycles.forEach(cycle => {
                let cycleHours = 0;
                for (const wwDateStr in employee.workWeeks) {
                    const wwDate = parseDate(wwDateStr);
                    if (wwDate && wwDate >= cycle.startDate && wwDate <= cycle.endDate) {
                        cycleHours += (parseFloat(employee.workWeeks[wwDateStr]) || 0);
                    }
                }
                if (cycleHours > REGULAR_HOURS_THRESHOLD) {
                    employee.accumulatedOvertimePay += (cycleHours - REGULAR_HOURS_THRESHOLD) * hourlyRate;
                }
            });

            const totalPaidOvertimePay = Object.values(paymentHistory[employee.payrollId] || {})
                .reduce((sum, payment) => sum + (payment.amount || 0), 0);
                
            employee.unpaidOvertimePay = Math.max(0, employee.accumulatedOvertimePay - totalPaidOvertimePay);
        }

        function recordOvertimePayment(payrollId, amount, paymentDate, notes) {
            if (!paymentHistory[payrollId]) {
                paymentHistory[payrollId] = {};
            }
            const paymentId = `payment_${Date.now()}`;
            paymentHistory[payrollId][paymentId] = {
                amount: parseFloat(amount),
                paymentDate,
                notes,
                recordedAt: new Date().toISOString()
            };
            
            calculatePayroll(employees[payrollId]);
            saveLocalData();
            updateAllTables();
        }

        function showPaymentDialog(payrollId) {
            const employee = employees[payrollId];
            if (!employee) return;
            
            const dialog = document.createElement('div');
            dialog.className = 'confirm-dialog active';
            dialog.innerHTML = `
                <div class="confirm-content">
                    <h3>ğŸ’° è¨˜éŒ„åŠ ç­è²»æ”¯ä»˜</h3>
                    <p><strong>å“¡å·¥ï¼š</strong>${employee.firstName} ${employee.lastName}</p>
                    <p><strong>æœªæ”¯ä»˜åŠ ç­è²»ï¼š</strong>${employee.unpaidOvertimePay.toFixed(2)}</p>
                    <div style="margin: 20px 0;">
                        <label><strong>æ”¯ä»˜é‡‘é¡ï¼š</strong></label>
                        <input type="number" id="payment-amount" value="${employee.unpaidOvertimePay.toFixed(2)}">
                    </div>
                    <div style="margin: 20px 0;">
                        <label><strong>æ”¯ä»˜æ—¥æœŸï¼š</strong></label>
                        <input type="date" id="payment-date" value="${new Date().toISOString().split('T')[0]}">
                    </div>
                    <div class="confirm-buttons">
                        <button class="btn-confirm" onclick="confirmPayment('${payrollId}')">ç¢ºèªæ”¯ä»˜</button>
                        <button class="btn-cancel" onclick="closeDialog()">å–æ¶ˆ</button>
                    </div>
                </div>`;
            document.body.appendChild(dialog);
        }

        function confirmPayment(payrollId) {
            const amount = parseFloat(document.getElementById('payment-amount').value);
            const paymentDate = document.getElementById('payment-date').value;
            if (isNaN(amount) || amount <= 0) {
                alert('è«‹è¼¸å…¥æœ‰æ•ˆçš„æ”¯ä»˜é‡‘é¡');
                return;
            }
            recordOvertimePayment(payrollId, amount, paymentDate, 'é€±æœŸåŠ ç­è²»æ”¯ä»˜');
            closeDialog();
            showMessage(`âœ… å·²è¨˜éŒ„ ${employees[payrollId].firstName} çš„åŠ ç­è²»æ”¯ä»˜`);
        }

        function showPaymentHistory(payrollId) {
            const employee = employees[payrollId];
            if (!employee || !paymentHistory[payrollId]) {
                showMessage('è©²å“¡å·¥æ²’æœ‰æ”¯ä»˜è¨˜éŒ„', 'warning');
                return;
            }
            const payments = Object.values(paymentHistory[payrollId]);
            const dialog = document.createElement('div');
            dialog.className = 'confirm-dialog active';

            let paymentList = payments.map(p => `
                <div style="border-bottom: 1px solid #eee; padding: 10px 0;">
                    <div><strong>é‡‘é¡ï¼š</strong>${p.amount.toFixed(2)}</div>
                    <div><strong>æ—¥æœŸï¼š</strong>${new Date(p.paymentDate).toLocaleDateString('en-AU')}</div>
                    ${p.notes ? `<div><strong>å‚™è¨»ï¼š</strong>${p.notes}</div>` : ''}
                </div>
            `).join('');

            dialog.innerHTML = `
                <div class="confirm-content">
                    <h3>ğŸ“‹ æ”¯ä»˜æ­·å²è¨˜éŒ„: ${employee.firstName} ${employee.lastName}</h3>
                    <div style="max-height: 300px; overflow-y: auto; margin: 20px 0;">
                        ${paymentList || '<p>æ²’æœ‰è¨˜éŒ„</p>'}
                    </div>
                    <div class="confirm-buttons">
                        <button class="btn-cancel" onclick="closeDialog()">é—œé–‰</button>
                    </div>
                </div>`;
            document.body.appendChild(dialog);
        }

        function getAllAvailableCycles() {
            if (timesheetData.length === 0) return [];
            const systemStartMonday = getMonday(SYSTEM_START_DATE);
            const today = new Date();
            const totalWeeksSinceSystemStart = Math.floor((today.getTime() - systemStartMonday.getTime()) / (7 * 24 * 60 * 60 * 1000));
            const totalCycles = Math.max(1, Math.ceil(totalWeeksSinceSystemStart / WEEKS_PER_CYCLE));
            
            return Array.from({ length: totalCycles }, (_, i) => {
                const cycle = i + 1;
                const startDate = new Date(systemStartMonday);
                startDate.setDate(startDate.getDate() + (i * WEEKS_PER_CYCLE * 7));
                const endDate = new Date(startDate);
                endDate.setDate(endDate.getDate() + (WEEKS_PER_CYCLE * 7) - 1);
                return { cycle, startDate, endDate };
            });
        }

        // å–å¾—ç¯©é¸å¾Œçš„å“¡å·¥æ¸…å–®
        function getFilteredEmployees() {
            const farmFilter = document.getElementById('farm-filter')?.value || '';
            const levelFilter = document.getElementById('level-filter')?.value || '';
            const employeeFilter = document.getElementById('employee-filter')?.value || '';
            const cycleFilter = document.getElementById('cycle-filter')?.value || '';
            
            return Object.values(employees).filter(employee => {
                if (farmFilter && employee.farm !== farmFilter) return false;
                if (levelFilter && employee.level !== levelFilter) return false;
                if (employeeFilter && employee.payrollId !== employeeFilter) return false;
                if (cycleFilter) {
                    const cycleInfo = calculateEmployeeCycle(employee);
                    if (cycleInfo.currentCycle.toString() !== cycleFilter) return false;
                }
                return true;
            });
        }

        // æ›´æ–°æ‰€æœ‰è¡¨æ ¼å’Œç¯©é¸å™¨
        function updateAllTables() {
            updateOverviewTable();
        }

        // æ›´æ–°ç¯©é¸é¸é …
        function updateFilterOptions() {
            const farmFilter = document.getElementById('farm-filter');
            const levelFilter = document.getElementById('level-filter');
            const employeeFilter = document.getElementById('employee-filter');
            const cycleFilter = document.getElementById('cycle-filter');
            if (!farmFilter) return;

            const farms = new Set(Object.values(employees).map(e => e.farm).filter(Boolean));
            const levels = new Set(Object.values(employees).map(e => e.level).filter(Boolean));
            
            const populateSelect = (select, options, currentVal) => {
                select.innerHTML = `<option value="">${select.firstElementChild.textContent}</option>`;
                options.forEach(opt => {
                    const option = new Option(opt, opt, false, opt === currentVal);
                    select.add(option);
                });
            };

            populateSelect(farmFilter, [...farms].sort(), farmFilter.value);
            populateSelect(levelFilter, [...levels].sort(), levelFilter.value);

            const employeeList = Object.values(employees).map(emp => ({
                id: emp.payrollId,
                name: `${emp.firstName} ${emp.lastName} (${emp.payrollId})`
            })).sort((a,b) => a.name.localeCompare(b.name));
            employeeFilter.innerHTML = '<option value="">æ‰€æœ‰å“¡å·¥</option>';
            employeeList.forEach(emp => {
                const option = new Option(emp.name, emp.id, false, emp.id === employeeFilter.value);
                employeeFilter.add(option);
            });
            
            const availableCycles = getAllAvailableCycles();
            cycleFilter.innerHTML = '<option value="">æ‰€æœ‰é€±æœŸ</option>';
            availableCycles.forEach(c => {
                 const text = `é€±æœŸ${c.cycle}: ${c.startDate.toLocaleDateString('en-AU')} - ${c.endDate.toLocaleDateString('en-AU')}`;
                 const option = new Option(text, c.cycle, false, c.cycle.toString() === cycleFilter.value);
                 cycleFilter.add(option);
            });
        }

        // æ¸…é™¤ç¯©é¸æ¢ä»¶
        function clearFilters() {
            document.getElementById('farm-filter').value = '';
            document.getElementById('level-filter').value = '';
            document.getElementById('employee-filter').value = '';
            document.getElementById('cycle-filter').value = '';
            updateAllTables();
        }

        // åˆ‡æ›è©³ç´°è³‡è¨Šé¡¯ç¤º
        function toggleDetails(button, payrollId) {
            const detailsRow = document.getElementById(`details-${payrollId}`);
            detailsRow.classList.toggle('is-open');
            button.textContent = detailsRow.classList.contains('is-open') ? '-' : '+';
        }

        // æ–°å¢ï¼šç·¨è¼¯å–®ç­†å·¥æ™‚
        function editHours(payrollId, workWeek) {
            const row = document.querySelector(`tr[data-work-week="${workWeek}"][data-payroll-id="${payrollId}"]`);
            row.querySelector('.hours-display').style.display = 'none';
            row.querySelector('.hours-input').style.display = 'inline-block';
            document.getElementById(`edit-actions-${payrollId}`).style.display = 'block';
        }

        // æ–°å¢ï¼šåˆªé™¤å–®ç­†å·¥æ™‚è¨˜éŒ„
        function deleteWorkWeek(payrollId, workWeek) {
            if (confirm(`ç¢ºå®šè¦åˆªé™¤å“¡å·¥ ${payrollId} æ–¼ ${workWeek} çš„å·¥æ™‚è¨˜éŒ„å—ï¼Ÿ`)) {
                timesheetData = timesheetData.filter(item => !(item.payrollId === payrollId && item.workWeekDate === workWeek));
                recalculateAllPayrolls();
                saveLocalData();
                updateAllTables();
                showMessage('âœ… å·¥æ™‚è¨˜éŒ„å·²åˆªé™¤');
            }
        }
        
        // æ–°å¢ï¼šå„²å­˜æ‰€æœ‰ä¿®æ”¹
        function saveAllEdits(payrollId) {
            const rows = document.querySelectorAll(`#details-table-${payrollId} tbody tr`);
            let hasChanges = false;
            rows.forEach(row => {
                const input = row.querySelector('.hours-input');
                if (input.style.display !== 'none') {
                    const workWeek = row.getAttribute('data-work-week');
                    const newHours = parseFloat(input.value);
                    const record = timesheetData.find(item => item.payrollId === payrollId && item.workWeekDate === workWeek);
                    if (record && !isNaN(newHours)) {
                        record.hours = newHours;
                        hasChanges = true;
                    }
                }
            });

            if (hasChanges) {
                recalculateAllPayrolls();
                saveLocalData();
                updateAllTables();
                showMessage('âœ… å·¥æ™‚ä¿®æ”¹å·²å„²å­˜');
            } else {
                cancelAllEdits(payrollId); // å¦‚æœæ²’è®Šæ›´ï¼Œå°±ç›´æ¥é‚„åŸUI
            }
        }

        // æ–°å¢ï¼šå–æ¶ˆæ‰€æœ‰ä¿®æ”¹
        function cancelAllEdits(payrollId) {
            updateAllTables(); // æœ€ç°¡å–®çš„æ–¹æ³•å°±æ˜¯é‡æ–°æ¸²æŸ“è¡¨æ ¼
        }

        // æ›´æ–°å“¡å·¥ç¸½è¦½è¡¨æ ¼
        function updateOverviewTable() {
            const container = document.getElementById('overview-table-container');
            if (Object.keys(employees).length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #777;">å°šæœªè¼‰å…¥å“¡å·¥è³‡æ–™ï¼Œè«‹å…ˆä¸Šå‚³å·¥æ™‚è¡¨ã€‚</p>';
                document.getElementById('overview-summary-cards').innerHTML = '';
                return;
            }
            
            updateFilterOptions();
            const filteredEmployees = getFilteredEmployees();

            if (filteredEmployees.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #777;">æ²’æœ‰ç¬¦åˆç¯©é¸æ¢ä»¶çš„å“¡å·¥è³‡æ–™ã€‚</p>';
                document.getElementById('overview-summary-cards').innerHTML = '';
                return;
            }

            let tableHTML = `
                <table class="employee-table">
                    <thead><tr><th></th><th>å“¡å·¥ç·¨è™Ÿ</th><th>å§“å</th><th>è¾²å ´</th><th>è·ç´š</th><th>æ™‚è–ª</th><th>å­£ç¯€ç¸½å·¥æ™‚</th><th>é€±æœŸå·¥æ™‚</th><th>é€±æœŸåŠ ç­è²»</th><th>ç´¯ç©åŠ ç­è²»</th><th>æœªæ”¯ä»˜åŠ ç­è²»</th><th>è·OTé–€æª»</th></tr></thead>
                    <tbody>`;
            
            // ä¿®æ­£ï¼šåˆå§‹åŒ–ç¸½è¨ˆè®Šæ•¸
            let totalHistoricalHours = 0;
            let totalCycleHours = 0;
            let totalCycleOvertimePay = 0;
            let totalAccumulatedOvertimePay = 0;
            let totalUnpaidOvertimePay = 0;
            let overtimeEmployeesCount = 0;

            filteredEmployees.sort((a, b) => a.payrollId.localeCompare(b.payrollId)).forEach(employee => {
                const cycleInfo = calculateEmployeeCycle(employee);
                const otThresholdDifference = REGULAR_HOURS_THRESHOLD - cycleInfo.cycleHours;

                // ä¿®æ­£ï¼šç´¯åŠ ç¸½è¨ˆ
                totalHistoricalHours += employee.totalHours || 0;
                totalCycleHours += cycleInfo.cycleHours || 0;
                totalCycleOvertimePay += employee.payrollData?.overtimePay || 0;
                totalAccumulatedOvertimePay += employee.accumulatedOvertimePay || 0;
                totalUnpaidOvertimePay += employee.unpaidOvertimePay || 0;
                if((employee.payrollData?.overtimeHours || 0) > 0) overtimeEmployeesCount++;

                const workWeeks = Object.entries(employee.workWeeks || {}).sort((a, b) => new Date(a[0]) - new Date(b[0]));
                let detailsTableHTML = workWeeks.length > 0 ? `
                    <table class="details-table" id="details-table-${employee.payrollId}">
                        <thead><tr><th>å·¥ä½œé€±</th><th>å·¥æ™‚</th><th>é€±åŠ ç­</th><th>æ“ä½œ</th></tr></thead>
                        <tbody>
                            ${workWeeks.map(([date, hours]) => {
                                const weeklyOvertimeHours = Math.max(0, hours - WEEKLY_HOURS_THRESHOLD);
                                return `<tr data-payroll-id="${employee.payrollId}" data-work-week="${date}">
                                    <td>${new Date(date).toLocaleDateString('en-AU')}</td>
                                    <td><span class="hours-display">${hours}</span><input type="number" class="hours-input" value="${hours}" style="display: none;"></td>
                                    <td>${weeklyOvertimeHours > 0 ? `<span class="status-overtime">${weeklyOvertimeHours.toFixed(1)}h</span>` : 'æ­£å¸¸'}</td>
                                    <td>
                                        <button class="btn-edit" onclick="editHours('${employee.payrollId}', '${date}')">ç·¨è¼¯</button>
                                        <button class="btn-delete" onclick="deleteWorkWeek('${employee.payrollId}', '${date}')">åˆªé™¤</button>
                                    </td>
                                </tr>`;
                            }).join('')}
                        </tbody>
                    </table>
                    <div class="edit-actions" style="display: none;" id="edit-actions-${employee.payrollId}">
                        <button class="btn-save" onclick="saveAllEdits('${employee.payrollId}')">å„²å­˜ä¿®æ”¹</button>
                        <button class="btn-cancel-edit" onclick="cancelAllEdits('${employee.payrollId}')">å–æ¶ˆ</button>
                    </div>` : '<div style="text-align:center;">ç„¡å·¥æ™‚è¨˜éŒ„</div>';
                
                tableHTML += `
                    <tr class="main-row">
                        <td><button class="toggle-details-btn" onclick="toggleDetails(this, '${employee.payrollId}')">+</button></td>
                        <td>${employee.payrollId}</td><td>${employee.firstName} ${employee.lastName}</td><td>${employee.farm || '-'}</td><td>${employee.level || '-'}</td>
                        <td class="money">${(employee.hourlyRate || 0).toFixed(2)}</td><td>${(employee.totalHours || 0).toFixed(2)}</td><td>${(cycleInfo.cycleHours || 0).toFixed(2)}</td>
                        <td class="money ${employee.payrollData?.overtimePay > 0 ? 'status-overtime' : ''}">${(employee.payrollData?.overtimePay || 0).toFixed(2)}</td>
                        <td class="money ${employee.accumulatedOvertimePay > 0 ? 'status-overtime' : ''}">
                            ${(employee.accumulatedOvertimePay || 0).toFixed(2)}
                            ${paymentHistory[employee.payrollId] ? `<button class="btn-edit" onclick="showPaymentHistory('${employee.payrollId}')" style="font-size:10px;padding:2px 4px;">æ­·å²</button>` : ''}
                        </td>
                        <td class="money ${employee.unpaidOvertimePay > 0 ? 'status-overtime' : ''}">
                            ${(employee.unpaidOvertimePay || 0).toFixed(2)}
                            ${employee.unpaidOvertimePay > 0 ? `<button class="btn-payment" onclick="showPaymentDialog('${employee.payrollId}')" style="font-size:10px;padding:2px 4px;">æ”¯ä»˜</button>` : ''}
                        </td>
                        <td class="${otThresholdDifference < 0 ? 'status-overtime' : ''}">${otThresholdDifference.toFixed(2)}</td>
                    </tr>
                    <tr class="details-row" id="details-${employee.payrollId}"><td colspan="12">${detailsTableHTML}</td></tr>`;
            });
            
            // ä¿®æ­£ï¼šä½¿ç”¨æ­£ç¢ºçš„ç¸½è¨ˆè®Šæ•¸æ¸²æŸ“é å°¾
            tableHTML += `
                    </tbody>
                    <tfoot style="font-weight:bold; background:#f0f0f0;">
                        <tr>
                            <td colspan="6" style="text-align:right;">ç¸½è¨ˆ</td>
                            <td>${totalHistoricalHours.toFixed(2)}</td>
                            <td>${totalCycleHours.toFixed(2)}</td>
                            <td class="money">${totalCycleOvertimePay.toFixed(2)}</td>
                            <td class="money">${totalAccumulatedOvertimePay.toFixed(2)}</td>
                            <td class="money">${totalUnpaidOvertimePay.toFixed(2)}</td>
                            <td>-</td>
                        </tr>
                    </tfoot>
                </table>`;
            container.innerHTML = tableHTML;
            
            // ä¿®æ­£ï¼šä½¿ç”¨æ­£ç¢ºè®Šæ•¸æ›´æ–°æ‘˜è¦å¡ç‰‡
            const summaryHTML = `
                <div class="summary-card"><h3>${filteredEmployees.length}</h3><p>ç¯©é¸å¾Œå“¡å·¥æ•¸</p></div>
                <div class="summary-card"><h3>${overtimeEmployeesCount}</h3><p>é€±æœŸåŠ ç­å“¡å·¥</p></div>
                <div class="summary-card"><h3>${totalCycleHours.toFixed(0)}</h3><p>é€±æœŸç¸½å·¥æ™‚</p></div>
                <div class="summary-card"><h3>${totalUnpaidOvertimePay.toFixed(0)}</h3><p>æœªæ”¯ä»˜åŠ ç­è²»</p></div>
            `;
            document.getElementById('overview-summary-cards').innerHTML = summaryHTML;
        }

        // æ–°å¢ï¼šåŒ¯å‡ºç¸½è¦½å ±å‘Š
        function exportOverview() {
            const filteredEmployees = getFilteredEmployees();
            if (filteredEmployees.length === 0) {
                showMessage('æ²’æœ‰è³‡æ–™å¯åŒ¯å‡º', 'warning');
                return;
            }

            let csvContent = "data:text/csv;charset=utf-8,";
            const headers = ['å“¡å·¥ç·¨è™Ÿ', 'å§“å', 'è¾²å ´', 'è·ç´š', 'æ™‚è–ª', 'å­£ç¯€ç¸½å·¥æ™‚', 'ç•¶å‰é€±æœŸå·¥æ™‚', 'é€±æœŸåŠ ç­è²»', 'ç´¯ç©åŠ ç­è²»', 'æœªæ”¯ä»˜åŠ ç­è²»', 'è·OTé–€æª»(h)'];
            csvContent += headers.join(',') + '\r\n';

            filteredEmployees.forEach(employee => {
                const cycleInfo = calculateEmployeeCycle(employee);
                const otThresholdDifference = REGULAR_HOURS_THRESHOLD - cycleInfo.cycleHours;
                const row = [
                    employee.payrollId,
                    `${employee.firstName} ${employee.lastName}`,
                    employee.farm || '',
                    employee.level || '',
                    (employee.hourlyRate || 0).toFixed(2),
                    (employee.totalHours || 0).toFixed(2),
                    (cycleInfo.cycleHours || 0).toFixed(2),
                    (employee.payrollData?.overtimePay || 0).toFixed(2),
                    (employee.accumulatedOvertimePay || 0).toFixed(2),
                    (employee.unpaidOvertimePay || 0).toFixed(2),
                    otThresholdDifference.toFixed(2)
                ];
                csvContent += row.join(',') + '\r\n';
            });

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `å“¡å·¥ç¸½è¦½å ±å‘Š_${new Date().toLocaleDateString('en-AU')}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showMessage('âœ… ç¸½è¦½å ±å‘Šå·²åŒ¯å‡º');
        }
